# Java基础

## 1. 面向对象和面向过程的内容、区别以及原因

### 面向过程：

- 内容：分析出实现需求所需要的步骤，通过函数一步一步实现这些步骤，接着依次调用
- 优点：性能上优于面向对象，因为类在调用的时候需要实例化，开销过大
- 缺点：不易维护、复用、扩展
- 用途：单片机、嵌入式开发、Linux/Unix等对性能要求较高的地方

### 面向对象：

- 内容：相对于面向过程而已，将繁琐的步骤，通过行为和功能，模块化，我们不必去关注如何实现的，会用就可以了
- 优点：易维护、易复用、易扩展，因为面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
- 缺点：性能上比面向过程低

### Java面向对象性能低根本原因： Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码，而面向过程语言大多都是直接编译成机械码在电脑上执行，但并不是所以的面向过程的脚本语言性能都比 Java 好。

## 2. Java 语言有哪些特点?

### 面向对象（封装，继承，多态）

### 平台无关性（ Java 虚拟机实现平台无关性）

### 安全可靠

### 编译与解释并存

## 3. 关于 JVM、JDK 和 JRE 最详细通俗的解答

### JVM

- JVM 是运行 Java 字节码的虚拟机。
- JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 从而实现 Java 语言的 “一次编译，随处可以运行” 。

### JDK（Java Development Kit）

- JDK 是 Java的编译时环境，是功能齐全的 Java SDK。
- 它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。
- 它能够创建和编译程序。

### JRE（Java Runtime Environment）

### JRE 是 Java 的运行时环境。

- 它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。
- 但是，它不能用于创建新程序。

## 4. OpenJDK 和 Oracle JDK 的对比

### OpenJDK：

- OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码
- 完全开源
- OpenJDK 性能稍逊

### Oracle JDK：

- Oracle JDK 是 OpenJDK 的一个实现，是基于 OpenJDK 7 所构建的
- 并不是完全开源
- Oracle JDK 性能更好

### 注意： Oracle JDK 更加稳定，虽然两者的代码几乎相同，但 Oracle JDK 有更多的类和一些错误的修复。

## 5.Java 和 C++ 的区别?

### 相同：

- 都是面向对象的语言
- 都拥有封装、继承和多态

### 异同：

- Java：

	- 不提供指针来直接访问内存，程序内存更加安全
	- 只能单一继承，但是接口可以多继承
	- 自动内存管理机制，不需要程序员手动释放无用内存

- C++：

	- 可以通过指针直接操纵内存
	- 支持多重继承
	- 开发种需要自己去管理内存

### 注意：在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。

## 6. 什么是 Java 程序的主类

主类是 Java 程序执行的入口点，一个程序中可以有多个类，但只能有一个类是主类。



### 在 Java 应用程序中，这个主类是指包含 main（）方法的类。

### 在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。

## 7.Java 应用程序与小程序之间有那些差别?

区别：



### 应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。

### 应用程序是从主线程启动(也就是 main()*方法)，而applet 小程序没有 main() 方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。

## 8. 字符型常量和字符串常量的区别?

### 从形式上：

- 字符常量是单引号引起的一个字符
- 字符串常量是双引号引起的若干个字符

### 从含义上：

- 字符常量相当于一个整型值( ASCII 值)，可以参加表达式运算
- 字符串常量代表一个地址值(该字符串在内存中存放位置)

### 从占内存大小上：

- 字符常量只占 2 个字节
- 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)

## 9. 构造器 Constructor 是否可被 override（重写）?

​	Constructor 不能被 override（重写），但是可以 overload（重载），所以你可以看到一个类中有多个构造函数的情况。



## 10. 重载和重写区别

### 重载： 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

### 重写： 重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。

| 区别点     | 重载方法 | 重写方法                                       |
| ---------- | -------- | ---------------------------------------------- |
| 发生范围   | 同一个类 | 子类当中                                       |
| 参数列表   | 必须修改 | 不能修改                                       |
| 返回类型   | 可修改   | 不能修改                                       |
| 异常       | 可修改   | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）         |
| 发生阶段   | 编译期   | 运行期                                         |



## 11. Java 面向对象编程三大特性: 封装、继承、多态

### 三大特性：

- 封装：把一个对象的属性私有化，同时为外界提供一些可以访问属性的方法
- 继承：从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。
- 多态：同一个行为具有多个不同的表现形式或形态

### 关于继承如下 3 点请记住：

- 子类拥有父类对象所有的属性和方法，但是父类中的私有属性和方法子类是无法访问，只是拥有。
- 子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。

### 多态存在的三个必要条件：

- 继承
- 重写
- 父类引用指向子类对象

### 在 Java 中有两种形式可以实现多态：

- 继承（多个子类对同一方法的重写）
- 接口（实现接口并覆盖接口中同一方法）。

## 12. String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

### 可变性

- String不可变原因： String 类中是使用 final 关键字修饰字符数组来保存字符串，所以 String 对象是不可变的。
- StringBuilder 与 StringBuffer可变原因：其都继承自 AbstractStringBuilder 类，该类也是使用字符数组保存字符串，但是没有用 final 关键字修饰，所以这两种对象都是可变的。

### 线程安全性

- String 中的对象是不可变的，也就可以理解为常量，线程安全。
- StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
- StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

### 性能

### 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象。

### StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。

### 相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

### 对于三者使用的总结：

- 1. 操作少量的数据：适用 String
- 2. 单线程操作字符串缓冲区下操作大量数据：适用 StringBuilder
- 3. 多线程操作字符串缓冲区下操作大量数据：适用 StringBuffer

## 13.自动装箱与拆箱

### 装箱：将基本类型包装成它们对应的引用类型。

### 拆箱：将包装类型转换为基本数据类型。

## 14. 在一个静态方法内调用一个非静态成员为什么是非法的?

### 非法

### 静态方法属于类，非静态方法属于某个实例对象，在调用静态方法的时候可能还没有创建实例对象，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

## 15. 在 Java 中定义一个不做事且没有参数的构造方法的作用

​	Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super()`来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。



## 16. import java 和 javax 有什么区别？

### 刚开始 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。

### 随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。

### 因此，最终决定 javax 包将成为标准 API 的一部分。

### 实际上 java 和 javax 没有区别，都只是一个名字。

## 17. 接口和抽象类的区别是什么？

### 接口：

- 所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现）。
- 接口中除了 static、final 变量，不能有其他变量。
- 一个类可以实现多个接口，接口自己本身可以通过 extends 关键字扩展多个接口。
- 接口方法的默认修饰符是 public
- 接口是对行为的抽象，是一种行为的规范。

### 抽象类：

- 抽象类中可以有非抽象的方法
- 抽象类对变量没有太多限制
- 一个类只能实现一个抽象类
- 抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰）
- 抽象是对类的抽象，是一种模板设计

## 18. 成员变量与局部变量的区别有哪些？

### 1. 从语法形式上看：

- 成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数。
- 成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。

### 2. 从变量在内存中的存储方式来看：

- 归属问题：

	- 如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的
	- 如果成员变量没有使用`static`修饰，那么这个成员变量是属于实例的。

- 储存位置：

	- 对象：存于堆内存
	- 局部变量：

		- 基本数据类型：那么存储在栈内存，
		- 引用数据类型：那存放的是指向堆内存对象的引用或者是指向常量池中的地址。

### 3. 从变量在内存中的生存时间上看：

- 成员变量是对象的一部分，它随着对象的创建而存在。
- 而局部变量随着方法的调用而自动消失。

### 4. 从变量是否赋值来看：

- 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值）
- 而局部变量则不会自动赋值。

## 19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?

### new 运算符，new 创建对象实例，对象引用指向对象实例。

### 一个对象引用可以指向 0 个或 1 个对象，一个对象可以被 n 个对象引用所指向

``` 
Student stu = new Student();
对象实例 --- new Student() --- 存放在堆内存中
对象引用 --- Student stu --- 存放在栈内存中
“=”操作符使对象引用指向刚创建的那个Student对象
```

## 20. 什么是方法的返回值?返回值在类的方法里的作用是什么?

### 方法的返回值：可以获取到的某个方法中的代码执行后，所产生的结果。（前提是该方法可能产生结果）。

### 返回值的作用：接收出结果，使得它可以用于其他的操作。

## 21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

### 主要作用：是完成对类对象的初始化工作。

### 是否可执行：可以执行。

### 原因：一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

## 22. 构造方法有哪些特性？

### 名字与类名相同。

### 没有返回值，但不能用 void 声明构造函数。

### 生成类的对象时自动执行，无需调用。

## 23. 静态方法和实例方法有何不同

### 1. 访问方式：

- 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。
- 实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。

### 2. 访问限制：

- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。
- 实例方法则无此限制。

## 24. 对象的相等与指向他们的引用相等,两者有什么不同?

### 对象相等：比较内存中存放的内容是否相等。

### 引用相等：比较的是他们指向的内存地址是否相等。

## 25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?

### 帮助子类做初始化工作。

## 26. == 与 equals(重要)

### ==：它的作用是判断两个对象的地址是否相等。即，判断两个对象是不是同一个对象.

- 基本数据类型，比较的是值
- 引用数据类型，比较的是内存地址

### equals()：它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

### 补充说明：

- String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

## 27. hashCode 与 equals (重要)

### hashCode() 的作用：获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。

### 散列表：存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

### hashCode（）与 equals（）的相关规定：

- 两个对象相等，则 hashcode 一定也是相同的
- 两个对象相等，对两个对象分别调用 equals 方法与hashCode方法都返回 true
- 两个对象有相同的 hashcode 值，它们也不一定是相等的
- 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
- hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

## 28. 为什么 Java 中只有值传递？

### 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。

### 一个方法可以改变一个对象参数的状态。

### 一个方法不能让对象参数引用一个新的对象。

## 29. 简述线程、进程、程序的基本概念。以及他们之间关系是什么?

### 线程：与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是，同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

### 进程：是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。当程序在执行时，将会被操作系统载入内存中。

### 程序：是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

### 关系：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于，基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

## 30. 线程有哪些基本状态?

| 状态名称      | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 初始状态，线程被构建，但是还没有调用start()方法              |
| RUNNABLE      | 运行状态，实际上可以细分成：ready(就绪) 和 running(运行) 状态. |
| BLOCKED       | 阻塞状态，表示线程进入阻塞状态，会让出 CPU 资源, 并暂时停止自己的执行 |
| WAITING       | 等待状态，表示线程进入等待状态, 它会等待其他线程做出一些特定的动作 |
| TIMED_WAITING | 超时等待状态，是等待状态的升级版, 它会有一个定时器, 在特定时间后自动唤醒该线程对象, 让其进入可运行状态. |
| TERMINATED    | 死亡状态, 表示线程终止. 当线程成功执行完成或线程抛出未捕获的 Exception 和 Error 或调用线程的stop方法时进入该状态. |

## 31.关于 final 关键字的一些总结

### 可修饰变量：

- 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改。
- 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

### 可修饰方法：

- 第一个原因是把方法锁定，以防任何继承类修改它的含义。（final修饰的方法不能被重写）
- 第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。
- 类中所有的 private 方法都隐式地指定为 final。

### 可修饰类：

- 当用 final 修饰一个类时，表明这个类不能被继承。
- final 类中的所有成员方法都会被隐式地指定为 final 方法。

## 32 Java 中的异常及处理

​	在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。

### Error（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。

### Exception（异常）：是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。

### 异常和错误的区别：

- 异常能被程序本身处理
- 错误是无法处理。

### Throwable 类常用方法：

- public string getMessage()：返回异常发生时的简要描述
- public string toString()：返回异常发生时的详细信息
- public string getLocalizedMessage()：返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同
- public void printStackTrace()：在控制台上打印 Throwable 对象封装的异常信息

### 异常处理总结：

- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。
- catch 块： 用于处理 try 捕获到的异常。
- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。

### 在以下 4 种特殊情况下，finally 块不会被执行：

### 1. 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行

### 2. 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行

### 3. 程序所在的线程死亡。

### 4. 关闭 CPU。

### 注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且finally 语句的返回值将会覆盖原始的返回值。

## 33.Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 transient 关键字修饰。

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。

## 34.获取用键盘输入常用的两种方法

方法 1：通过 Scanner

``` java
Scanner sc = new Scanner(System.in);
String s  = sc.nextLine();
sc.close();
```

方法 2：通过 BufferedReader

``` java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String s = br.readLine();
```



## 35.Java 中 IO 流

### Java 中 IO 流分为3种

- 按照流的流向分，分为输入流和输出流。
- 按照操作单元划分，分为字节流和字符流。
- 按照流的角色划分，分为节点流和处理流。

### Java Io 流共涉及 40 多个类，且都是从如下 4 个抽象类基类中派生出来的。

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

### 既然有了字节流,为什么还要有字符流?

- 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是非常耗时。
- 如果我们不知道编码类型，就很容易出现乱码问题。
- 所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。

	- 如果音频文件、图片等媒体文件用字节流比较好
	- 如果涉及到字符的话使用字符流比较好。

### BIO,NIO,AIO 有什么区别?

- BIO (Blocking I/O)：同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
- NIO (Non-blocking/New I/O)： NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
- AIO (Asynchronous I/O)： AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。

## 36.  static、this、super关键字总结

### static 关键字主要有以下四种使用场景：

- 修饰成员变量和成员方法：

	- 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。
	- 被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()

- 静态代码块： 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
- 静态内部类（static修饰类的话只能修饰内部类）：

	- 静态内部类与非静态内部类之间存在一个最大的区别：

		- 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，
		- 但是静态内部类却没有。没有这个引用就意味着：

			- 1. 它的创建是不需要依赖外围类的创建。
			- 2. 它不能使用任何外围类的非static成员变量和方法。

- 静态导包(用来导入类中的静态资源，1.5之后的新特性)： 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

### this关键字用于两个地方：

- this.employees.length：访问类Manager的当前实例的变量。
- this.report（）：调用类Manager的当前实例的方法。
- 注意：此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。

### 使用 this 和 super 要注意的问题：

- 在构造器中使用 `super()` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
- this、super不能用在static方法中。
- 简单解释一下：

	- 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。
	- 而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象。

		- this和super是属于对象范畴的东西，
		- 而静态方法是属于类范畴的东西。

## 37. Collections 工具类和 Arrays 工具类常见方法总结

### Collections

- 排序操作``` 
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。
```


- 查找,替换操作``` 
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素
```


- 同步控制``` 
synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。
```



### Arrays类的常见操作

- 排序：sort()``` 
// Arrays.sort(int[] a)方法按照数字顺序排列指定的数组。
// Arrays.sort(int[] a, int fromIndex, int toIndex)按升序排列数组的指定范围
// Arrays.parallelSort(int[] a)按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序
// Arrays.parallelSort给字符数组排序，sort也可以
```


- 查找：binarySearch()``` 
// Arrays.binarySearch(int[] a, char c)
```


- 比较：equals()``` 
// Arrays.equals(int[] a, int[] b)
```


- 填充：fill()``` 
// Arrays.fill(int[] a, int b)
// Arrays.fill(int[] a, int start, int end, int b)
```


- 转列表：asList()``` 
// Arrays.asList(int[] a)//把数组转换为集合
```


- 转字符串：toString()``` 
// Arrays.toString(int[] a)//把数组转换为字符串
```


- 复制：copyOf()``` 
// Arrays.copyOf(int[] a, int num)//拷贝前num个到新数组
// Arrays.copyOfRange(int[] a, int start, int end)将指定数组的指定范围复制到新数组中
```



## 38. 深拷贝 vs 浅拷贝

### 浅拷贝：

- 对基本数据类型进行值传递。
- 对引用数据类型进行引用传递。

### 深拷贝：

- 对基本数据类型进行值传递。
- 对引用数据类型，创建一个新的对象，并复制其内容。

## 39.强引用，软引用，弱引用，虚引用

### 强引用：是使用最普遍的引用，如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存控件不足时，java虚拟机宁愿抛出OutOfMemoryError也不会随意回收具有强引用的对象来解决内存不足的问题。

### 软引用：如果一个对象只具有软引用，则内存空间足够，垃圾回收器便不会回收它，如果内存空间不足了，那么垃圾回收器就会回收这些对象的内存，软引用可用于实现内存敏感的高速缓存。

### 弱引用：有弱引用的对象生命周期更短，垃圾回收器一旦发现就只具有弱引用的对象，不管当前内存是否足够，都会将其回收，但是垃圾回收器是一个优先级很低的线程，不一定会很快的发现那些只具有弱引用的对象，弱引用可用于解决内存泄漏的问题。

### 虚引用：虚引用与其它几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列 （ReferenceQueue）联合使用，垃圾回收器回收对象时，该对象还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

| 引用类型 | 被回收时间    | 用途           | 生存时间      |
| -------- | ------------- | -------------- | ------------- |
| 强引用   | 从来不会      | 对象的一般状态 | JVM停止运行时 |
| 软引用   | 内存不足时    | 对象缓存       | 内存不足时    |
| 弱引用   | jvm垃圾回收时 | 对象缓存       | gc运行后      |
| 虚引用   | 未知          | 未知           | 未知          |



## 40.内存溢出和内存泄漏的区别

### 内存溢出：（Out Of Memory---OOM）

- 系统已经不能再分配出你所需要的空间

### 内存泄漏： (Memory Leak)

- 强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象
- 分类

	- 常发性内存泄漏：发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
	- 偶发性内存泄漏：发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
	- 一次性内存泄漏：发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
	- 隐式内存泄漏：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。

## Throw 和 throws 的区别

### 位置不同

- throws 用在函数上，后面跟的是异常类，可以跟多个，throw 用在函数内，后面跟的是异常对象

### 功能不同

- throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到
- throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象

### 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理

## Java 反射

### 动态语言

- 动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言

### 反射机制概念

- 在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法

### 反射的应用场合

- 编译时类型和运行时类型

	- Person p=new Student();
	- 其中编译时类型为 Person，运行时类型为 Student

### Java 反射 API

- 1.  Class 类：反射的核心类，可以获取类的属性，方法等信息。
- 2.  Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。
- 3.  Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。
- 4.  Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法

### 反射使用步骤（获取 Class 对象、调用对象方法）

- 1.  获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。
- 2.  调用 Class 类中的方法，既就是反射的使用阶段。
- 3.  使用反射 API 来操作这些信息。

### 获取 Class 对象的 3 种方法

- 调用某个对象的 getClass() 方法

	- Person p=new Person();
	- Class clazz=p.getClass();

- 调用某个类的 class 属性来获取该类对应的 Class 对象

	- Class clazz=Person.class;

- 使用 Class 类中的 forName() 静态方法 ( 最安全 / 性能最好 )

	- Class clazz=Class.forName("类的全路径"); (最常用)

### 获取对象中的方法，属性，构造方法

- //获取 Person 类的 Class 对象
Class clazz=Class.forName("reflection.Person");
- //获取 Person 类的所有方法信息
Method[] method=clazz.getDeclaredMethods();
for(Method m:method){
System.out.println(m.toString());
}
- //获取 Person 类的所有成员属性信息
Field[] field=clazz.getDeclaredFields();
for(Field f:field){
System.out.println(f.toString());
}
- //获取 Person 类的所有构造方法信息
Constructor[] constructor=clazz.getDeclaredConstructors();
for(Constructor c:constructor){
System.out.println(c.toString());
}

### 创建对象的两种方法

- Class 对象的 newInstance()

	- 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例
	- 要求

		- 该 Class 对象对应的类有默认的空构造器

- 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例

## JAVA  注解

### 概念

- 提供的一种为程序元素设置元数据的方法

### 标准注解

- @Override

	- 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误

- @Deprecated

	- 标记过时方法。如果使用该方法，会报编译警告

- @SuppressWarnings

	- 指示编译器去忽略注解中声明的警告

### 4种元注解

- @Target 修饰的对象范围
- @Retention 定义被保留的时间长短

	- SOURCE

		- 在源文件中有效（即源文件保留）

	- CLASS

		- 在 class 文件中有效（即 class 保留）

	- RUNTIME

		- 在运行时有效（即运行时保留）

- @Documented  描述-javadoc
- @Inherited   阐述了某个被标注的类型是被继承

## JAVA  内部类

### 静态内部类

- 1.  静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。
- 2.  静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。
- 3.  其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：
Out.Inner inner =new Out.Inner();
inner.print();
- 4.  Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。

### 成员内部类

- 定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的除外）

### 局部内部类(定义在方法中的类)

### 匿名内部类(要继承一个父类或者实现一个接口、直接使用new来生成一个对象的引用)

## JAVA  泛型

## JAVA 序列化(创建可复用的 Java 对象)

### 序列化

- 保存 ( 持久化 ) 对象及其状态到内存或者磁盘
- 序列化对象以字节数组保持 - 静态成员不保存
- 序列化用户远程对象传输
- Serializable 实现序列化

	- 在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化

- ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化
- writeObject  和 readObject 自定义序列化策略
- 序列化 ID

	- 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致

### Transient 关键字，阻止该变量被序列化到文件中

- 1.  在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
- 2.  服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。

*XMind - Trial Version*